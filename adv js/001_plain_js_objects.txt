# -------------- 20 key points about dot notation in JavaScript: ------------- #

1. Basic Syntax: Dot notation uses a dot (.) to access properties and methods of objects.
\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
object.property
//////////////////////////////////////////////

2. Readability: Dot notation is more readable and concise compared to bracket notation.

3. Property Names: Dot notation can only be used with valid JavaScript identifiers (alphanumeric characters, $, and _).

4. No Special Characters: Property names with spaces, hyphens, or other special characters cannot be accessed using dot notation.

5. No Starting Digits: Property names starting with digits cannot be accessed using dot notation.

6. Static Property Access: Dot notation is typically used when property names are known at the time of coding.

7. Method Access: Dot notation is used to call methods of an object.
\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
object.methodName()
//////////////////////////////////////////////

8. Chaining: Dot notation allows method chaining for cleaner and more succinct code.
\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
object.method1().method2()
//////////////////////////////////////////////

9. Nested Properties: Dot notation can be used to access nested properties.
\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
object.property1.property2
//////////////////////////////////////////////

10. Prototype Properties: Dot notation can access properties inherited from an object's prototype.

11. Performance: Dot notation is generally faster than bracket notation because property names are resolved at compile time.

12. Code Completion: Most modern IDEs provide code completion for properties and methods accessed using dot notation.

13. Static Analysis: Tools like linters can better analyze and catch errors in code using dot notation.

14. Property Deletion: Dot notation can be used with the delete operator to remove properties.
\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
delete object.property
//////////////////////////////////////////////

15. Object Creation: Dot notation is used to define properties on an object during its creation.
\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
const obj = {
  property: value
}
//////////////////////////////////////////////

16. Error Handling: Attempting to access a non-existent property using dot notation returns undefined without throwing an error.

17. Read-Only Properties: Dot notation can be used to read properties, but attempting to write to read-only properties will fail silently or throw an error in strict mode.

18. Accessing Functions: Dot notation can be used to assign and call functions as object methods.
\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
object.method = function() { ... }
//////////////////////////////////////////////

19. This Keyword: Methods accessed via dot notation can use the this keyword to refer to the containing object.

20. Consistency: Using dot notation consistently can make code easier to read and maintain by keeping property access uniform across the codebase.

# ------------ 20 key points about bracket notation in JavaScript: ----------- #

1. Basic Syntax: Bracket notation uses square brackets ([]) to access properties of objects.
\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
object['property']
//////////////////////////////////////////////

2. Dynamic Property Access: Bracket notation allows the use of variables to access properties.
\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
let prop = 'name';
console.log(object[prop]);
//////////////////////////////////////////////

3. Special Characters: Property names with spaces, hyphens, or special characters can be accessed using bracket notation.
\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
object['first-name'] = 'John';
console.log(object['first-name']);
//////////////////////////////////////////////

4. Starting Digits: Property names that start with digits can be accessed using bracket notation.
\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
object['123property'] = 'value';
console.log(object['123property']);
//////////////////////////////////////////////

5. Computed Property Names: Bracket notation can be used to define properties with expressions.
\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
let key = 'age';
let person = { [key]: 25 };
console.log(person.age);
//////////////////////////////////////////////

6. Accessing Nested Properties: Bracket notation can be used to access nested properties.
\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
console.log(object['parent']['child']);
//////////////////////////////////////////////

7. Method Access: Bracket notation can be used to access methods dynamically.
\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
let method = 'greet';
object[method]();
//////////////////////////////////////////////

8. Prototype Properties: Bracket notation can access inherited properties from the object's prototype.

9. Deletion: Bracket notation can be used with the delete operator to remove properties.
\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
delete object['property'];
//////////////////////////////////////////////

10. Optional Chaining: Bracket notation can be combined with optional chaining to safely access properties.
\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
console.log(object?.['property']);
//////////////////////////////////////////////

11. Symbols: Bracket notation can be used to access properties with symbol keys.
\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
let sym = Symbol('key');
object[sym] = 'value';
console.log(object[sym]);
//////////////////////////////////////////////

12. Using in Loops: Bracket notation is useful in for...in loops to iterate over object properties.
\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
for (let key in object) {
  console.log(object[key]);
}
//////////////////////////////////////////////

13. Function Properties: Bracket notation can dynamically assign functions as properties of an object.
\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
object['method'] = function() { console.log('Hello'); };
object['method']();
//////////////////////////////////////////////

14. Handling Undefined Properties: Accessing a non-existent property using bracket notation returns undefined without error.
\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
console.log(object['nonExistent']); // undefined
//////////////////////////////////////////////

15. Dynamic Object Construction: Bracket notation allows for the dynamic construction of objects.
\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
let obj = {};
let keys = ['name', 'age'];
let values = ['Alice', 30];
for (let i = 0; i < keys.length; i++) {
  obj[keys[i]] = values[i];
}
console.log(obj);
//////////////////////////////////////////////

16. Array Index Access: Bracket notation is used to access array elements.
\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
let arr = ['apple', 'banana'];
console.log(arr[1]); // banana
//////////////////////////////////////////////

17. JSON Parsing: Bracket notation is often used to access properties in JSON objects.
\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
let json = '{"name": "John"}';
let obj = JSON.parse(json);
console.log(obj['name']);
//////////////////////////////////////////////

18. Setting New Properties: Bracket notation can set new properties on objects dynamically.
\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
object['newProperty'] = 'newValue';
//////////////////////////////////////////////

19. Using with Proxies: Bracket notation can be used within proxy handlers to intercept property access.
\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
let handler = {
  get: function(target, property) {
    return property in target ? target[property] : 'default';
  }
};
let proxy = new Proxy(object, handler);
console.log(proxy['nonExistent']); // default
//////////////////////////////////////////////

20. Combining with String Literals: Template literals can be used with bracket notation for dynamic property names.
\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
let part = 'name';
console.log(object[`full${part}`]); // object['fullname']
//////////////////////////////////////////////
