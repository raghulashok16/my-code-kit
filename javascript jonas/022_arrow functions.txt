Arrow Functions in JavaScript ðŸ›©ï¸ðŸ›©ï¸
âœ… Arrow functions (also called "fat arrow functions") are a concise syntax
 for writing function expressions in JavaScript, introduced in ES6 (ECMAScript 2015). 
âœ… They provide a shorter syntax compared to traditional function expressions
 and have some differences in how they handle the `this` keyword.

âœ… Basic Syntax
ðŸš©ðŸš©ðŸš©ðŸš©
// Traditional function expression
const add = function(a, b) {
  return a + b;
};

// Arrow function equivalent
const add = (a, b) => {
  return a + b;
};
âš¡âš¡âš¡âš¡

Shorter Variations ðŸ›©ï¸ðŸ›©ï¸
1.âœ…  Single parameter: Parentheses are optional
ðŸš©ðŸš©ðŸš©ðŸš©
   const square = x => {
     return x * x;
   };
âš¡âš¡âš¡âš¡

2.âœ…  No parameters: Must include empty parentheses
ðŸš©ðŸš©ðŸš©ðŸš©
   const greet = () => {
     return "Hello!";
   };
âš¡âš¡âš¡âš¡

3.âœ…  Single expression: Implicit return (no curly braces needed)
ðŸš©ðŸš©ðŸš©ðŸš©
   const multiply = (a, b) => a * b;
âš¡âš¡âš¡âš¡

4.âœ…  Returning an object: Wrap in parentheses
ðŸš©ðŸš©ðŸš©ðŸš©
   const createPerson = (name, age) => ({ name: name, age: age });
âš¡âš¡âš¡âš¡

Key Differences from Regular Functions ðŸ›©ï¸ðŸ›©ï¸
1.âœ…  `this` binding: Arrow functions don't have their own `this` context - they inherit `this`
 from the surrounding lexical scope.
ðŸš©ðŸš©ðŸš©ðŸš©
   function Timer() {
     this.seconds = 0;
     
     // Traditional function - has its own 'this'
     setInterval(function() {
       this.seconds++; // Won't work - 'this' refers to the interval
     }, 1000);
     
     // Arrow function - inherits 'this' from Timer
     setInterval(() => {
       this.seconds++; // Works as expected
     }, 1000);
   }
âš¡âš¡âš¡âš¡

2.âœ…  No `arguments` object: Arrow functions don't have their own `arguments` object.
ðŸš©ðŸš©ðŸš©ðŸš©
   const showArgs = () => {
     console.log(arguments); // ReferenceError: arguments is not defined
   };
âš¡âš¡âš¡âš¡

3.âœ…  Cannot be used as constructors: Arrow functions cannot be called with `new`.
ðŸš©ðŸš©ðŸš©ðŸš©
   const Foo = () => {};
   const bar = new Foo(); // TypeError: Foo is not a constructor
âš¡âš¡âš¡âš¡

4.âœ…  No prototype property: Arrow functions don't have a `prototype` property.


âœ… When to Use Arrow Functions
- For short, simple functions (especially callbacks)
- When you want to preserve the lexical `this` binding
- For functional programming patterns (map, filter, reduce)

âœ… When Not to Use Arrow Functions
- As object methods (if you need access to the object via `this`)
- When you need the `arguments` object
- When you need to use the function as a constructor
- For event handlers where you might need access to the event target via `this`

âœ… Examples in Common Use Cases
ðŸš©ðŸš©ðŸš©ðŸš©
// Array methods
const numbers = [1, 2, 3];
const doubled = numbers.map(n => n * 2);

// Promises
fetch('https://api.example.com')
  .then(response => response.json())
  .then(data => console.log(data))
  .catch(error => console.error('Error:', error));

// Short callbacks
button.addEventListener('click', () => console.log('Clicked!'));
âš¡âš¡âš¡âš¡

âœ… Arrow functions provide a cleaner, more concise syntax in many cases, but it's
 important to understand their differences from traditional functions to use them effectively.