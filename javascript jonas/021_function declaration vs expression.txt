âœ… In JavaScript, functions can be defined in two main ways: function declarations and function expressions.
âœ… Here are the key differences between them:

1. Function Declaration ðŸ›©ï¸ðŸ›©ï¸
- Defined using the `function` keyword followed by a name.
- Hoisted: Can be called before its definition in the code.
- Has its own scope (`this`, `arguments`, `super`, `new.target`).


âœ… Syntax: 
ðŸš©ðŸš©ðŸš©ðŸš©
function greet() {
  console.log("Hello!");
}
âš¡âš¡âš¡âš¡

âœ… Example: 
ðŸš©ðŸš©ðŸš©ðŸš©
greet(); // Works due to hoisting

function greet() {
  console.log("Hello!");
}
âš¡âš¡âš¡âš¡

2. Function Expression ðŸ›©ï¸ðŸ›©ï¸
- Defined by assigning a function to a variable.
- Not hoisted: Cannot be called before its definition.
- Can be anonymous (unnamed) or named.
- Often used in callbacks, IIFEs, and closures.

âœ… Syntax:
ðŸš©ðŸš©ðŸš©ðŸš©
const greet = function() {
  console.log("Hello!");
};
âš¡âš¡âš¡âš¡

âœ… Example:
ðŸš©ðŸš©ðŸš©ðŸš©
greet(); // Error: greet is not defined yet (no hoisting)

const greet = function() {
  console.log("Hello!");
};
âš¡âš¡âš¡âš¡

âœ… Key Differences: 
| Feature               | Function Declaration | Function Expression    |
|-----------------------|----------------------|----------------------  |
| Hoisting              | âœ… Yes               | âŒ No                 | 
| Name (identity)       | Has a name           | Can be anonymous       |
| Usage                 | General functions    | Callbacks, closures    |
| Assignment            | Not required         | Assigned to a variable |

âœ… When to Use Which?
- Use Function Declarations when you need hoisting or a standalone function.
- Use Function Expressions when you need to pass a function as an argument (callback) or assign it dynamically.

Arrow Functions (Special Case of Function Expression) ðŸ›©ï¸ðŸ›©ï¸
ðŸš©ðŸš©ðŸš©ðŸš©
const greet = () => console.log("Hello!");
âš¡âš¡âš¡âš¡

âœ… Summary: 
- Function Declarations are hoisted and have a name.
- Function Expressions are not hoisted and can be anonymous.
- Arrow Functions are a concise form of function expressions (but without their own `this` binding).
